# operater {{{
# shorthand variable declaration
snippet : "name := value"
${1} := ${0}
endsnippet

snippet = "name = value"
${1} = ${0}
endsnippet

snippet eq "name == value"
${1} == ${0}
endsnippet

snippet ne "name != value"
${1} != ${0}
endsnippet

snippet lt "name < value"
${1} < ${0}
endsnippet

snippet le "name <= value"
${1} <= ${0}
endsnippet

snippet gt "name > value"
${1} > ${0}
endsnippet

snippet ge "name >= value"
${1} >= ${0}
endsnippet
# }}}

# keyword {{{
# break        default      func         interface    select
# case         defer        go           map          struct
# chan         else         goto         package      switch
# const        fallthrough  if           range        type
# continue     for          import       return       var

snippet br "break" 
break 
endsnippet

# case
snippet c "case ...:"
case ${1:value}:
	${0:${VISUAL}}
endsnippet

# channel
snippet ch "chan Type"
chan ${0:int}
endsnippet

# constant
snippet co "const XXX Type = ..."
const ${1:NAME} ${2:Type} = ${0:0}
endsnippet

# constants
snippet cos "const ( ... )"
const (
	${1:NAME} ${2:Type} = ${3:value}
	${0}
)
endsnippet

# constants with iota
snippet io "const ( ... = iota )"
const (
	${1:NAME} ${2:Type} = iota
	${0}
)
endsnippet

# continue
snippet cn "continue"
continue
endsnippet

# continue
snippet ct "continue"
continue
endsnippet

# default case
snippet de "default: ..."
default:
	${0:${VISUAL}}
endsnippet

# defer
snippet df "defer someFunction()"
defer ${1:func}(${2})
${0}
endsnippet

# if condition
snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

# if initiate condition
snippet i; "if; ... { ... }"
if ${1:_, ok} := ${2:map[key]}; ${3:condition} {
	${0:${VISUAL}}
}
endsnippet


# else snippet
snippet el "else { ... }"
else {
	${0:${VISUAL}}
}
endsnippet

# if...else... condition
snippet ie "if ... else ..."
if ${1:condition} {
	${2:${VISUAL}}
} else {
	${0}
}
endsnippet

# if...else if ... condition
snippet iei "if ... else if ..."
if ${1:condition} {
	${2:${VISUAL}}
} else if ${3:condition} {
	${0}
}
endsnippet

snippet r "return" 
return 
endsnippet

snippet re "return err" 
return err
endsnippet

snippet rn "return nil" 
return nil
endsnippet

snippet r, "return nil, err" 
return ${1:nil}, ${2:err}
endsnippet

snippet ra "range" 
range 
endsnippet


# for range loop
snippet rk "for v := range items { ... }"
for ${2:k} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

# for range loop
snippet rv "for k, v := range items { ... }"
for _, ${2:v} := range ${1} {
	${0:${VISUAL}}
}
endsnippet



# map
snippet m "map[Type]Type" 
map[${1:string}]${0:string}
endsnippet

# package
snippet pa "package ..." b
// Package $1 provides ${2:...}
package ${1:main}
${0}
endsnippet



# struct
snippet st "type T struct { ... }"
type ${1:Type} struct {
	${0}
}
endsnippet

# variable declaration
snippet v "var x Type" b
var ${1:x} ${2:Type}
endsnippet

# variable initialization
snippet vv "var x Type [= ...]" b
var ${1:x} ${2:Type}${3: = ${0:value}}
endsnippet

# variables declaration
snippet vs "var ( ... )" b
var (
	${1:x} ${2:Type}${3: = ${0:value}}
)
endsnippet


# }}}

# built-in function {{{
# make
snippet mk "make(any)"
make(${0})
endsnippet

# panic
snippet pn "panic(err)"
panic(${1:err})
${0}
endsnippet

# }}}

# data type {{{

snippet by "byte" 
byte
endsnippet

snippet bo "bool" i
bool
endsnippet

# snippet i "int"
# int 
# endsnippet

snippet sr "string" 
string 
endsnippet

snippet er "error" 
error 
endsnippet

snippet tr "true" 
true 
endsnippet

snippet fa "false" 
false 
endsnippet

snippet [b "[]byte"  i
[]byte
endsnippet

snippet [s "[]string" i
[]string
endsnippet

snippet [i "[]int" i
[]int
endsnippet




# json field tag
snippet js "\`json:key\`"
\`json:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# yaml field tag
snippet ya "\`yaml:key\`"
\`yaml:"${1:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

#  field tag
snippet ` "\`input:key\`"
\`${1:input}:"${2:`!v  go#util#snippetcase(matchstr(getline("."), '\w\+'))`}"\`
endsnippet

# }}}

# error {{{
# error snippet
snippet e "if err != nil { return  err }" !b
if err != nil {
    ${1:return err}
}
${0}
endsnippet


snippet e, "if err != nil { return nil, err }" !b
if err != nil {
    return nil, err
}
${0}
endsnippet


# error multiple return
snippet e, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, ${2:err}
}
${0}
endsnippet

# error log.Fatal
snippet ef "if err != nil { log.Fatal(err)}" !b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error log.Fatal
snippet ep "if err != nil { log.Println(err)}" !b
if err != nil {
	log.Println(err)
}
${0}
endsnippet
# }}}

# function and method {{{
# function
snippet fn "func Function(...) [error] { ... }"
// $1 ${4:DOC ...}
func ${1:name}(${2:params})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
	${0:${VISUAL}}
}
endsnippet

snippet me "func (self Type) Method(...) [error] { ... }"
// $3 ${6:DOC ...}
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
	${0:${VISUAL}}
}
endsnippet
# }}}

# standard library {{{
snippet ss "strings"
strings
endsnippet

snippet sv "strconv"
strconv
endsnippet

snippet es "errors"
errors
endsnippet

snippet tm "time"
time
endsnippet



# fmt {{{
# Fmt Printf debug
snippet pf "fmt.Printf(...)"
fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})
endsnippet

# Fmt Println debug
snippet pl "fmt.Println(...)"
fmt.Println("${1:${VISUAL}}")
endsnippet

# Fmt Errorf debug
snippet ef "fmt.Errorf(...)"
fmt.Errorf("${1:${VISUAL}}")
endsnippet

# }}}


# }}}

# http {{{
snippet hf "http.HandlerFunc"
// $1 ${2:DOC ...}
func ${1:HandlerFunc}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
}
endsnippet

snippet hm "http.HandlerFunc method"
// $3 ${4:DOC ...}
func (${1:receiver} ${2:type}) ${3:HandlerFunc}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
}
endsnippet


snippet mw "middleware"
// $1 ${2:DOC ...}
func ${1:myMiddleware}(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		${0:// TODO: Execute our middleware logic here...}

		h.ServeHTTP(w, r) 
    })
}
endsnippet

# method
snippet mwm "func (self Type) middleware(h http.Handler) http.Handler"
// $3 ${4:DOC ...}
func (${1:receiver} ${2:type}) ${3:myMiddleware}(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		${0:// TODO: Execute our middleware logic here...}

		h.ServeHTTP(w, r) 
	})
}
endsnippet
# }}}

# global {{{
global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal
# }}}
