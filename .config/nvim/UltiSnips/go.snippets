# keyword

# variable initialization
snippet vi "var x Type" b
var ${1:name} ${2:type}
endsnippet

# variable declaration
snippet vd "var x Type [= ...]"
var ${1:name} ${2:Type} = ${3:value}
endsnippet

# variables declaration
snippet vds "var ( ... )"
var (
	${1:name} ${2:Type}${3: = ${4:value}}
)
${0}
endsnippet

# type alias
snippet r "return value" b
return ${0:v}
endsnippet


# type alias
snippet rn "return nil" b
return ${0:nil}
endsnippet

# type alias
snippet re "return err" b
return err
endsnippet

# type alias
snippet rvn "return v, nil" b
return ${1:v}, nil
endsnippet

# type alias
snippet rve "return v, err" b
return ${1:v}, err
endsnippet

# type alias
snippet t "type T Type" b
type ${1:T} ${2:struct{}} 
endsnippet

# struct
snippet struct "type T struct { ... }" b
type ${1:Type} struct {
	${2}
}
endsnippet

# interface
snippet interface "type T interface { ... }" b
type ${1:Type} interface {
	${2}
}
endsnippet

# A Buffer needs no initialization.
snippet buf "var buf bytes.Buffer" b
var buf bytes.Buffer
endsnippet

# byte slice
snippet bs "[]byte" w
[]byte
endsnippet

# string slice
snippet ss "[]string" w
[]string
endsnippet

# time
snippet tm "time.Time"
time.Time
endsnippet

# append
snippet ap "append(slice, value)"
append(${1:slice}, ${0:value})
endsnippet

# inline if ok
snippet ok "if v, ok := value; ok { ... }" b
if ${1:x}, ok := ${2:value}; ok {
	${2:${VISUAL}}
}
endsnippet

# inline if ok
snippet ra "for _, v := range sth." b
for ${1:k}, ${2:v} := range ${3:sth.} {
	${0:do things.}
}
endsnippet

# error

# error snippet
snippet er "Error return" !b
if err != nil {
	return err
}
endsnippet

# error multiple return
snippet er, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, ${2:err}
}
endsnippet

# error log.Fatal
snippet erlf "if err != nil { log.Fatal(err)}" !b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error log.Fatal
snippet erlp "if err != nil { log.Println(err)}" !b
if err != nil {
	log.Println(err)
}
${0}
endsnippet

# error handle
snippet erh "Error handle" !b
if err != nil {
	${1}
}
${0}
endsnippet


# defer
snippet df "defer someFunction()"
defer ${1:func}(${2})
${0}
endsnippet

snippet dff "defer func() { ... }"
defer func() {
	${1:${VISUAL}}
}()
${0}
endsnippet

# defer recover
snippet dfr
defer func() {
	if err := recover(); err != nil {
		${1:${VISUAL}}
	}
}()
${0}
endsnippet

# print

# fmt Fprintf 
snippet fpf "fmt.Fprintf(...)"
fmt.Fprintf(${1:w}, "${2:${VISUAL}} = %+v\n", $2)
endsnippet

# Fmt Fprintln 
snippet fpn "fmt.Println(...)"
fmt.Fprintln(${1:w}, "${2:${VISUAL}}")
endsnippet

# Fmt Fprint
snippet fp "fmt.Print(...)"
fmt.Fprint(${1:w}, "${2:${VISUAL}}")
endsnippet

# Fmt Printf debug
snippet pf "fmt.Printf(...)"
fmt.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

# Fmt Println debug
snippet pn "fmt.Println(...)"
fmt.Println("${1:${VISUAL}}")
endsnippet

# Fmt Print debug
snippet p "fmt.Print(...)"
fmt.Print("${1:${VISUAL}}")
endsnippet

# sprintf
snippet spf "fmt.Sprintf(...)"
fmt.Sprintf("${1:%s}", ${2:var})
endsnippet

# Fmt Sprintln 
snippet spn "fmt.Sprintln(...)"
fmt.Sprintln("${1:${VISUAL}}")
endsnippet

# Fmt Sprint
snippet sp "fmt.Sprint(...)"
fmt.Print("${1:${VISUAL}}")
endsnippet

# Fmt Errorf debug
snippet ef "fmt.Errorf(...)"
fmt.Errorf("${1:${VISUAL}}")
endsnippet

# log.Fatal
snippet lf "log.Fatal(v)"
log.Fatal("${1:${value}}")
endsnippet

# log.Fatalln
snippet lfn "log.Fatalln(v)"
log.Fatalln("${1:${value}}")
endsnippet

# log.Fatalf
snippet lff "log.Fatalf(format,v...)"
log.Fatalf("${1:format},${2:${value}}")
endsnippet

# log.Print
snippet lp "log.Print(v)"
log.Print("${1:${value}}")
endsnippet

# log.Println
snippet lpn "log.Println(v)"
log.Println("${1:${value}}")
endsnippet

# log.Fatalf
snippet lpf "log.Printf(format,v...)"
log.Printf("${1:format},${2:${value}}")
endsnippet


# function

snippet fu "function" b
func ${1:funcName}(${2}) ${3:error} {
	${4}
}
${0}
endsnippet

snippet fr "function on receiver" b
func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
	${6}
}
${0}
endsnippet

# ============================== http ==============================
# http.Handler
snippet hdr "http.Handler" 
http.Handler
endsnippet

snippet hdrf "http.HandlerFunc(HandlerFunc)" 
http.HandlerFunc
endsnippet

snippet dhdrf "http.HandlerFunc(func(w,r){...})" !b
http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	${3:fmt.Fprintf(w, "hello world")}
})
endsnippet

snippet thdrf "http.HandlerFunc(func(w,r){...})" !b
http.HandlerFunc(${1:VISUAL})
endsnippet

snippet hd "mux.Handle(pattern, handler)" !b
${1:http}.Handle("${2:/}", ${3:Handler}) 
${0}
endsnippet

snippet hdf "mux.HandleFunc(pattern, handler func(...))" !b
${1:http}.HandleFunc("${2:/}", func(w http.ResponseWriter, r *http.Request) {
	${3:fmt.Fprintf(w, "hello world")}
})
${0}
endsnippet

# http.Request
snippet req "http.Request" w
http.Request
endsnippet

# http.NewRequest
snippet nreq "http.Request" b
r, err := http.NewRequest("${1:GET}", "${2:/}", ${3:nil})
${0}
endsnippet

# http.Response
snippet res "http.Response" w
http.Response
endsnippet

# http.ResponseWriter
snippet resw "http.ResponseWriter" w
http.ResponseWriter
endsnippet

snippet hr "http.ResponseWriter" 
http.Redirect(w, r, {$1:url}, ${2:http.StatusSeeOther})
endsnippet

snippet fh "http.HandlerFunc" !b
func ${1:handler}(w http.ResponseWriter, r *http.Request) {
	${2:fmt.Fprintf(w, "hello world")}
}
${0}
endsnippet

snippet fhr "http.HandlerFunc on receiver" !b
func (${1:receiver} ${2:type}) ${3:methName}(w http.ResponseWriter, r *http.Request) {
	${4:fmt.Fprintf(w, "hello world")}
}
${0}
endsnippet


snippet mw "func mw( next http.Handler ) http.Handler" !b
func ${1:myMiddleware}(next http.Handler) http.Handler {

	hd := ${2:http.Handler}

	${3:// TODO: do some middleware config here ...}

	return hd
}
endsnippet

snippet mwr "func (r receiver) mw( next http.Handler ) http.Handler" !b
func (${1:receiver} ${2:type}) ${3:myMiddleware}(next http.Handler) http.Handler {

	hd := ${5:http.Handler}

	${6:// TODO: do some middleware config here ...}

	return hd
}
endsnippet

snippet mc "middleware: handler closure" !b
func ${1:myMiddleware}(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		${0:// TODO: Execute our middleware logic here...}

		next.ServeHTTP(w,r)
	})
}
endsnippet

snippet mcr "middleware: handler closure on receiver" !b
func (${1:receiver} ${2:type}) ${3:myMiddleware}(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		${0:// TODO: Execute our middleware logic here...}

		next.ServeHTTP(w,r)
	})
}
endsnippet

# ============================== testing ==============================
# test function
snippet ft "func TestXYZ(t *testing.T) { ... }"
func Test${1:Function}(t *testing.T) {
	${0:${VISUAL}}
}
endsnippet

# test table snippet
snippet tt
var tests = []struct {
	name string
	expected string
	given string
}{
	{"${1}", "${2}", "${3}",},
}
for _, tt := range tests {
	tt := tt
	t.Run(tt.name, func(t *testing.T){
		actual := ${0:${VISUAL}}(tt.given)
		if actual != tt.expected {
				t.Errorf("$0(%s): expected %s, actual %s", tt.given, tt.expected, actual)
		}

	})
}
endsnippet

# test error handling
snippet te "if err != nil { t.Errorf(...) }"
if ${1:err != nil} {
	t.Error(${2:err})
}
${0}
endsnippet

# test error handling
snippet tef "if err != nil { t.Errorf(...) }"
if ${1:err} != ${2:nil} {
	t.Errorf("want: %q, got: %q", $1, $2)
}
${0}
endsnippet

# test error handling
snippet tf "if err != nil { t.Errorf(...) }"
if ${1:err != nil} {
	t.Fatal(${2:err})
}
${0}
endsnippet

# test error handling
snippet tff "if err != nil { t.Errorf(...) }"
if ${1:err != nil} {
	t.Fatalf("${2:message}")
}
${0}
endsnippet

# vecty


snippet comp "vecty Component"
type ${1:name} struct {
	vecty.Core
	${2: prop}
}

// Render implements the vecty.Component interface.
func (${3} *$1) Render() vecty.ComponentOrHTML {
	${0}
}
endsnippet

# time

# time.Sleep
snippet sleep "time.Sleep(duration)"
time.Sleep(${1:1} * ${2:time.Second})
endsnippet

# now in unix
snippet nowu "time.Now().Unix()" bw
nowu := time.Now().Unix()
endsnippet

# now
snippet now "time.Now()" bw
now := time.Now()
endsnippet


# bufio

#bufio.NewReader(io.Reader)
snippet rd "reader := bufio.NewReader(io.Reader)"
reader := bufio.NewReader(${1:os.Stdin})
${0}
endsnippet

#bufio.NewScanner(io.Reader)
snippet scn "scanner := bufio.NewScanner(io.Reader)"
scanner := bufio.NewScanner(${1:os.Stdin})
${0}
endsnippet


# rand

snippet intn "intn := rand.Intn(${1:n})"
intn := rand.Intn(${1:100})
${0}
endsnippet

